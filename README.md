# Отчёт по лабораторной работе (MPI)

### Установка нужных библиотек
```bash
sudo apt update  
sudo apt install openmpi-bin openmpi-doc libopenmpi-dev python3-pandas python3-matplotlib python3-numpy -y
```
### Запуск экспериментов (пример)
в корне проекта:
```bash
./utils/run_experiments_1.sh
./utils/run_experiments_2.sh
./utils/run_experiments_3.sh
```

## Задание 1 — вычисление π методом Монте-Карло

**Условия**
- процессы: `1 4 8`  
- выборки: `10^6 15*10^5 10^7 15*10^6 2*10^7`  
- повторов на конфигурацию: `3`

**Графики**  
- Ускорение
  
![Иллюстрация к проекту](https://github.com/TypicalCode0/distributed_computing/blob/main/utils/graphics_1/speedup.png)    
- Эффективность (ускорение/количество процессоров)
  
![Иллюстрация к проекту](https://github.com/TypicalCode0/distributed_computing/blob/main/utils/graphics_1/efficiency.png)  

**Наблюдения**
- ?

**Вывод**
- ?

## Задание 2 — умножение матрицы на вектор

**Режимы тестирования**
- `row` (разбиение по строкам)  
- `col` (разбиение по столбцам)  
- `block` (блочное разбиение / сетка процессов)  
**Условия**
- процессы: `1 4 8`  
- выборки: `10^3 5*10^3 10^4`  
- повторов на конфигурацию: `3`

**Графики**  
- Ускорение

![Иллюстрация к проекту](https://github.com/TypicalCode0/distributed_computing/blob/main/utils/graphics_2/speedup_row.png)    
![Иллюстрация к проекту](https://github.com/TypicalCode0/distributed_computing/blob/main/utils/graphics_2/speedup_col.png)  
![Иллюстрация к проекту](https://github.com/TypicalCode0/distributed_computing/blob/main/utils/graphics_2/speedup_block.png)  
- Эффективность (ускорение/количество процессоров)
  
![Иллюстрация к проекту](https://github.com/TypicalCode0/distributed_computing/blob/main/utils/graphics_2/efficiency_row.png)  
![Иллюстрация к проекту](https://github.com/TypicalCode0/distributed_computing/blob/main/utils/graphics_2/efficiency_col.png)  
![Иллюстрация к проекту](https://github.com/TypicalCode0/distributed_computing/blob/main/utils/graphics_2/efficiency_block.png)  


**Наблюдения**
- ?

**Вывод**
- ?


## Задание 3 — умножение матриц (алгоритм Кэннона)

Алгоритм заключается 
в распределении матриц по квадратной сетке процессов с последующими 
циклическими сдвигами блоков.

Из процессов строится квадратная сетка sqrt(p) на sqrt(p), где p - количество процессов

Теор. вычислительная сложность: O(N^3/p)

Теор. коммуникационная сложность: O(P*x + y * N^2/p)

,где 
x - задержка передачи процесса, y - передача блока


**Условия**
- число процессов: полный квадрат (`1 4 9`)  
- `n` должно делиться на `sqrt(p)`
- выборки: `6*10^2 12*10^2 15*10^2`
- повторов на конфигурацию: `3`

**Графики**  
- Ускорение
    
![Иллюстрация к проекту](https://github.com/TypicalCode0/distributed_computing/blob/main/utils/graphics_3/speedup.png)    
- Эффективность (ускорение/количество процессоров)
  
![Иллюстрация к проекту](https://github.com/TypicalCode0/distributed_computing/blob/main/utils/graphics_3/efficiency.png)  

**Наблюдения**
- Почти линейное ускорение на малом количестве процессов (до 4) - кривые для всех размеров матриц растут близко к идеальной линии, 
что указывает на равномерное распределение нагрузки между процессами и низкие расходы на коммуникации
- При увеличении числа процессов рост ускорения для малых матриц (600) замедляется: связано с тем, что размер локальных 
блоков уменьшается (N^2/p) и доля коммуникации становится заметнее относительно вычислений
- Для матриц размером 1200 и 1500 при 9 процессах ускорение выше и ближе к идеальному, 
поскольку вычислительная часть растет кубически (N^3), что перевешивает коммуникационную квадратичную часть (N^2)

**Вывод**
- Алгоритм Кэннона реализован корректно: наблюдается линейное ускорение на малом числе процессов и предсказуемое снижение эффективности при масштабировании
- Экспериментальные результаты подтверждают теоретические оценки вычислительной и коммуникационной сложности алгоритма Кэннона

## Итоговые выводы

- 

